<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Scrollama Demo: Fixed CSS</title>
    <meta name="description" content="Scrollama Demo: Fixed CSS">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link href="style.css" rel="stylesheet" type="text/css">
</head>

<body>
<section id='intro'>
    <p class='intro__overline'>
        <a href='https://github.com/russellgoldenberg/scrollama'>scrollama.js</a>
    </p>
    <h1 class='intro__hed'>Demo: Sticky Graphic</h1>
    <p class='intro__dek'>
        Start scrolling to see how it works.
    </p>
</section>
<section id='scroll'>
    <div class='scroll__graphic'>
        <div class='chart'>
            <svg></svg>
            <p></p>
        </div>
    </div>
    <div class='scroll__text'>
        <div id="bin1" class='step' data-step='1'>
            <p>STEP 1</p>
        </div>
        <div class='step' data-step='2'>
            <p>STEP 2</p>
        </div>
        <div class='step' data-step='3'>
            <p>STEP 3</p>
        </div>
        <div class='step' data-step='4'>
            <p>STEP 4</p>
        </div>
        <div class='step' data-step='5'>
        <p>STEP 5</p>
        </div>
        <div class='step' data-step='5'>
            <p>STEP 5</p>
        </div>
    </div>
</section>
<section id='outro'></section>
<div class='debug'></div>
<script src='https://d3js.org/d3.v4.min.js'></script>
<script src='https://unpkg.com/intersection-observer'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/scrollama/1.4.1/scrollama.min.js'></script>

<script>
    // using d3 for convenience
    var container = d3.select('#scroll');
    var graphic = container.select('.scroll__graphic');
    var chart = graphic.select('.chart');
    var text = container.select('.scroll__text');
    var step = text.selectAll('.step');
    var entered = 0;

    var big_array = new Array(300);
    var small_array = new Array(2);

    // initialize the scrollama
    var scroller = scrollama();
    // generic window resize listener event
    function handleResize() {
        // 1. update height of step elements
        var stepHeight = Math.floor(window.innerHeight * 0.75);
        step.style('height', stepHeight + 'px');
        // 2. update width/height of graphic element
        var bodyWidth = d3.select('body').node().offsetWidth;
        graphic
            .style('width', bodyWidth + 'px')
            .style('height', window.innerHeight + 'px');
        var chartMargin = 32;
        var textWidth = text.node().offsetWidth;
        var chartWidth = graphic.node().offsetWidth - textWidth - chartMargin;
        chart
            .style('width', chartWidth + 'px')
            .style('height', Math.floor(window.innerHeight / 2) + 'px');
        // 3. tell scrollama to update new element dimensions
        scroller.resize();
    }
    // scrollama event handlers
    function handleStepEnter(response) {
        var margin;
        var width;
        var height;
        var svg;
        var main;
        var g;
        var path;
        if(entered === 0){
            margin = {top: 20, right: 15, bottom: 60, left: 60}

            width = chart.node().getBoundingClientRect().width;
            height = chart.node().getBoundingClientRect().height;
            var path_data = [[4, 5], [12, 5]]
            svg = chart
                .select('svg')
                .attr('class', 'chart_data')
                .attr('width', width )
                .attr('height',height );
            let line = d3.line()
                .x(function(d) { return d[0]; })
                .y(function(d) { return d[1]; });
            main = svg.append('g')
                .attr('width', width)
                .attr('height', height)
                .attr('class', 'main');
            g = main.append("svg:g").attr("class", "data_points");

             g.append('path')
                 .attr('d', line(path_data))
                 .attr("class", "primary_path");

            entered = 1;
        }else{
             margin = {top: 20, right: 15, bottom: 60, left: 60}

             width = chart.node().getBoundingClientRect().width;
             height = chart.node().getBoundingClientRect().height;
             svg = chart
                .select('svg')
             main = svg.select('g');
             g = main.select(".data_points");//.attr("class", "data_points");
            path = svg.select('path');
        }

        // response = { element, direction, index }
        // add color to current step only
        step.classed('is-active', function (d, i) {
            return i === response.index;
        })
        ////////////////////////////////////////////
        if (response.index === 0) {
            small_array = [[2, 5], [12, 5]];
            let other_array = [[2, 5], [2, 5]];

            var x = d3.scaleLinear()
                .domain([0, 20])//d3.max(data, function(d) { return d[0]; })])
                .range([0, width]);

            var y = d3.scaleLinear()
                .domain([0, 10])//d3.max(data, function(d) { return d[1]; })])
                .range([height, 0]);

            let line = d3.line()
                .x(function(d) { return x(d[0]); })
                .y(function(d) { return y(d[1]); });
            g.selectAll("path")
                .attr("d", line(other_array))
                .style("stroke", "black")
                .style("stroke-width", "5");

            g.selectAll(".scatter-dots")
                .data(small_array)
                .enter().append("circle")
                .attr('fill','blue')
                .attr('stroke','black')
                .attr("class", "scatter-dots")
                .attr("cx", function (d, i) {
                    return x(d[0]);
                })
                .attr("cy", function (d) {
                    return y(d[1]);
                })
                .attr("r", 40);
            g.selectAll(".scatter-dots").transition()
                .duration(1000)
                .attr("cx", function (d) {
                    return x(d[0]);
                })
                .attr("cy", function (d) {
                    return y(d[1]);
                })
                .attr("r", 40);

            searchFirst(g);
        }

        if (response.index === 1) {
            collideTwoDots(g);
        }
        if(response.index === 2){
            expandGraph(g);
        }
    }
    async function searchFirst(g){
        var width = chart.node().getBoundingClientRect().width;
        var height = chart.node().getBoundingClientRect().height;
        var x = d3.scaleLinear()
            .domain([0, 20])//d3.max(data, function(d) { return d[0]; })])
            .range([0, width]);

        var y = d3.scaleLinear()
            .domain([0, 10])//d3.max(data, function(d) { return d[1]; })])
            .range([height, 0]);

        let temp_data = [[6, 5], [12, 5]];
        let temp_path_data = [[6, 5], [6, 5]];
        let line = d3.line()
            .x(function(d) { return x(d[0]); })
            .y(function(d) { return y(d[1]); });

        g.selectAll(".scatter-dots")
            .data(temp_data);
        g.selectAll(".scatter-dots").transition()
            .duration(1000)
            .attr("cx", function (d) {
                return x(d[0]);
            })
            .attr("cy", function (d) {
                return y(d[1]);
            });
        g.selectAll("path")
            .transition()
            .duration(1000)
            .attr("d", line(temp_path_data));
        await sleep(800);
        g.selectAll("path")
            .transition()
            .duration(1200)
            .attr("d", line(temp_data));
        await sleep(1000);
        g.selectAll("path")
            .transition()
            .duration(800)
            .style("stroke", "#32CD32")

    }

    async function collideTwoDots(g){
        small_array[0] = [11, 5];
        small_array[1] = [12, 5];
        for(var i = 0; i < 300; i++){
            big_array[i] = [Math.random()*100 - 50, Math.random()*100 - 50];
        }
        var width = chart.node().getBoundingClientRect().width;
        var height = chart.node().getBoundingClientRect().height;

        var x = d3.scaleLinear()
            .domain([0, 20])//d3.max(data, function(d) { return d[0]; })])
            .range([ 0, width ]);

        var y = d3.scaleLinear()
            .domain([0, 10])//d3.max(data, function(d) { return d[1]; })])
            .range([ height, 0 ]);

        let line = d3.line()
            .x(function(d) { return x(d[0]); })
            .y(function(d) { return y(d[1]); });

        var dots = g.selectAll(".scatter-dots")
            .data(small_array);
        dots.exit().remove();

        g.selectAll(".many-scatter-dots")
            .data(big_array)
            .enter().append("circle")
            .attr("class", "many-scatter-dots")
            .attr("cx", function (d) { return x(d[0]); } )
            .attr("cy", function (d) { return y(d[1]); } )
            .attr("r", 40)
            .style("opacity", 0);

        g.selectAll(".many-scatter-dots")
            .transition()
            .attr("cx", function (d) { return x(d[0]); } )
            .attr("cy", function (d) { return y(d[1]); } )
            .attr("r", 40)
            .style("opacity", 0);

        dots.transition()
            .duration(1000)
            .attr("cx", function (d) { return x(d[0]); } )
            .attr("cy", function (d) { return y(d[1]); } )
            .attr("r", 40);

        g.selectAll("path")
            .style("opacity",0);

        await sleep(800)
        dots.transition()
            .duration(1000)
            .style("fill", "red");

    }
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    async function expandGraph(g){

  //      small_array[0] = [7, 5];
    //    small_array[1] = [12, 5];
        var width = chart.node().getBoundingClientRect().width;
        var height = chart.node().getBoundingClientRect().height;

        var x = d3.scaleLinear()
            .domain([-50, 50])//d3.max(data, function(d) { return d[0]; })])
            .range([ 0, width ]);

        var y = d3.scaleLinear()
            .domain([-50, 50])//d3.max(data, function(d) { return d[1]; })])
            .range([ height, 0 ]);

        var dots = g.selectAll(".scatter-dots")
            .data(small_array);
        var dots2 = g.selectAll(".many-scatter-dots")
            .data(big_array);

        let mycolor = d3.rgb(13, 13, 185);
        let mycolor2 = d3.rgb(0, 0, 0);

        dots.transition()
            .duration(1000)
            .attr("cx", function (d) { return x(d[0]); } )
            .attr("cy", function (d) {  return y(d[1]); } )
    //        .style("fill", mycolor)
            .attr("r", 4);

        dots2.transition()
            .duration(1000)
            .attr("cx", function (d) {return x(d[0]); } )
            .attr("cy", function (d) {return y(d[1]); } )
            .style("fill", mycolor2)
            .attr("r", 4)
            .style("opacity", 1);

        await sleep(2000);



        for(var i = 0; i < 300; i++){
            big_array[i] = [Math.random()*100 - 50, Math.random()*100 - 50];
        }

        small_array[0] = [Math.random()*100 - 50, Math.random()*100 - 50];
        small_array[1] = [Math.random()*100 - 50, Math.random()*100 - 50];

        let line = d3.line()
            .x(function(d) { return x(d[0]); })
            .y(function(d) { return y(d[1]); });
        let other_array = [small_array[0], small_array[0]];
        g.selectAll("path")
            .attr("d", line(other_array))
            .style("stroke", "gray")
            .style("stroke-width", "2")
            .style("opacity", "1");

        dots = g.selectAll(".scatter-dots")
            .data(small_array);
        dots2 = g.selectAll(".many-scatter-dots")
            .data(big_array);
        dots2.transition()
            .duration(2000)
            .attr("cx", function (d) {return x(d[0]); } )
            .attr("cy", function (d) {return y(d[1]); } );
        dots.transition()
            .duration(2000)
            .attr("cx", function (d) {return x(d[0]); } )
            .attr("cy", function (d) {return y(d[1]); } );

        await sleep(2000);
        for(let i = 0; i < 10; i++){
            other_array[1] = big_array[i];
            console.log(big_array[i]);
            g.selectAll("path")
                .transition()
                .duration(300)
                .attr("d", line(other_array));
            await sleep(600)
            other_array[1] =other_array[0];
            g.selectAll("path")
                .transition()
                .duration(300)
                .attr("d", line(other_array));

        }



    }

    function handleContainerEnter(response) {
        // response = { direction }
        // sticky the graphic (old school)
        graphic.classed('is-fixed', true);
        graphic.classed('is-bottom', false);
    }
    function handleContainerExit(response) {
        // response = { direction }
        // un-sticky the graphic, and pin to top/bottom of container
        graphic.classed('is-fixed', false);
        graphic.classed('is-bottom', response.direction === 'down');
    }
    function init() {
        // 1. force a resize on load to ensure proper dimensions are sent to scrollama
        handleResize();
        // 2. setup the scroller passing options
        // this will also initialize trigger observations
        // 3. bind scrollama event handlers (this can be chained like below)
        scroller.setup({
            container: '#scroll',
            graphic: '.scroll__graphic',
            text: '.scroll__text',
            step: '.scroll__text .step',
        })
            .onStepEnter(handleStepEnter)
            .onContainerEnter(handleContainerEnter)
            .onContainerExit(handleContainerExit);
        // setup resize event
        window.addEventListener('resize', handleResize);
    }
    // kick things off
    init();
    var bin1 = step.select("#bin1")
    bin1.html("text here")
</script>
</body>

</html>
