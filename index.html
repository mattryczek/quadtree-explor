<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Quadtrees for Collision Detection Performance</title>
    <meta name="description" content="Quadtrees for Collision Detection">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link href="style.css" rel="stylesheet" type="text/css">
</head>

<body>
<div id='intro'>
    <h1 class="intro__title">Quadtrees for Collision Detection Performance</h1>
    <br>
    <div class="intro__info">
    <p class='intro__text'>
        Most video games rely on some kind of collision detection algorithm in order to implement
        essential gameplay mechanics. Regardless of the chosen algorithm, the problem with existing
        implementation is scale. In many video games, large environments can contain thousands of objects that
        the player can interact with. Currently, the best way to limit computational cost is to decrease the
        number of times the algorithm is run. In order to do this, developers utilize quadtrees,
        a data structure that eliminates checks for impropable collisions. Scroll to explore an illustrated
        breakdown of quadtrees and their use.
        
    </p>
    <p class='intro__text intro__img'>
        <img src="galaga.gif">
    </p>
    </div>
</div>
<section id='scroll'>
    <div class='scroll__graphic'>
        <div class='chart'>
            <svg></svg>
            <p></p>
        </div>
    </div>
    <div class='scroll__text'>
        <div class='step' data-step='1'>
            <p class='step__title'>Small Scale Detection</p>
            <br>
            <p class='step__text'>
                Game engines must be able to update a game's state depending on object interaction
                (or lack thereof), requiring frequent checks for collisions. In this case, we see two 
                objects that don't collide. We use our detection algorithm (shown
                here as a line drawn between objects) to verify this.
            </p>
        </div>
        <div class='step' data-step='2'>
            <p class='step__text'>
                Now, we see two objects that do collide. In this case, detection is trivial, 
                as we're only dealing with two objects. </p> 
                <br><br><br>
            <p class='step__text'>
                Let's look at what happens 
                with<br> <input type="number" name="numObj" value="300" max="1000" min="2"> objects...
            </p>
        </div>
        <div class='step' data-step='3'>
            <p class='step__title'>Large Scale Detection</p>
            <br>
            <p class="step__text">
                When we have a large number of objects, checking for collisions
                using our current method becomes much more expensive. Users expect
                fluid gameplay, free of constant delays. Although the detection algorithm
                may be completed quickly, performing this computation for all pairs of objects
                has a cost that increases exponentially with the number of objects.
            </p>
        </div>
        <div class='step' data-step='4'>
            <p class='step__title'>Dividing Space to Build a Quadtree</p>
            <br>
            <p class='step__text'>
                How can we cut down on object
                comparisons? Consider the probability that two objects
                collide. This probability is not uniform between all objects - some 
                have a much lower chance of colliding than others. The use of quadtrees
                relies on a simple intuition: objects that are near one another are more likely
                to have collided. To check objects against their neighbors, we first have to 
                figure out which objects are close to each other.
                <br><br>
                In order to create our tree, we recursively divide our 2D space into equally 
                sized quadrants, until each quadrant contains at least one and at most four
                objects.
            </p>
        </div>
        <div class='step' data-step='5'>
            <p class='step__title'>Visualizing the Tree</p>
            <br>
            <p class='step__text'>
                Here's more text for the tree explanation.
            </p>
        </div>
    </div>
</section>
<section id='outro'>
    <svg class="quadtree">

    </svg>
    <svg class="anim">

    </svg>
</section>
<script src='https://d3js.org/d3.v4.min.js'></script>
<script src='https://unpkg.com/intersection-observer'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/scrollama/1.4.1/scrollama.min.js'></script>

<script>
    // using d3 for convenience
    var container = d3.select('#scroll');
    var graphic = container.select('.scroll__graphic');
    var chart = graphic.select('.chart');
    var text = container.select('.scroll__text');
    var step = text.selectAll('.step');
    var entered = 0;

    var big_array = new Array(300);
    var small_array = new Array(2);

    // initialize the scrollama
    var scroller = scrollama();
    // generic window resize listener event
    function handleResize() {
        // 1. update height of step elements
        var stepHeight = Math.floor(window.innerHeight * 0.6);
        step.style('height', stepHeight + 'px');
        // 2. update width/height of graphic element
        var bodyWidth = d3.select('body').node().offsetWidth;
        graphic
            .style('width', bodyWidth + 'px')
            .style('height', window.innerHeight + 'px');
        var chartMargin = 32;
        var textWidth = text.node().offsetWidth;
        var chartWidth = graphic.node().offsetWidth - textWidth - chartMargin;
        chart
            .style('width', chartWidth + 'px')
            .style('height', Math.floor(window.innerHeight / 2) + 'px');
        // 3. tell scrollama to update new element dimensions
        scroller.resize();
    }
    // scrollama event handlers
    function handleStepEnter(response) {
        var margin;
        var width;
        var height;
        var svg;
        var main;
        var g;
        var path;
        if(entered === 0){
            margin = {top: 20, right: 15, bottom: 60, left: 60}

            width = chart.node().getBoundingClientRect().width;
            height = chart.node().getBoundingClientRect().height;
            var path_data = [[4, 5], [12, 5]]
            svg = chart
                .select('svg')
                .attr('class', 'chart_data')
                .attr('width', width )
                .attr('height',height );
            let line = d3.line()
                .x(function(d) { return d[0]; })
                .y(function(d) { return d[1]; });
            main = svg.append('g')
                .attr('width', width)
                .attr('height', height)
                .attr('class', 'main');
            g = main.append("svg:g").attr("class", "data_points");

             g.append('path')
                 .attr('d', line(path_data))
                 .attr("class", "primary_path");

            entered = 1;
        }else{
             margin = {top: 20, right: 15, bottom: 60, left: 60}

             width = chart.node().getBoundingClientRect().width;
             height = chart.node().getBoundingClientRect().height;
             svg = chart
                .select('svg');
             main = svg.select('g');
             g = main.select(".data_points");//.attr("class", "data_points");
            path = svg.select('path');
        }

        // response = { element, direction, index }
        // add color to current step only
        step.classed('is-active', function (d, i) {
            return i === response.index;
        });
        ////////////////////////////////////////////
        if (response.index === 0) {
            small_array = [[2, 5], [12, 5]];
            let other_array = [[2, 5], [2, 5]];

            var x = d3.scaleLinear()
                .domain([0, 20])//d3.max(data, function(d) { return d[0]; })])
                .range([0, width]);

            var y = d3.scaleLinear()
                .domain([0, 10])//d3.max(data, function(d) { return d[1]; })])
                .range([height, 0]);

            let line = d3.line()
                .x(function(d) { return x(d[0]); })
                .y(function(d) { return y(d[1]); });
            g.selectAll("path")
                .attr("d", line(other_array))
                .style("stroke", "black")
                .style("stroke-width", "5");

            g.selectAll(".scatter-dots")
                .data(small_array)
                .enter().append("circle")
                .attr('fill','blue')
                .attr('stroke','black')
                .attr("class", "scatter-dots")
                .attr("cx", function (d, i) {
                    return x(d[0]);
                })
                .attr("cy", function (d) {
                    return y(d[1]);
                })
                .attr("r", 40);
            g.selectAll(".scatter-dots").transition()
                .duration(1000)
                .attr("cx", function (d) {
                    return x(d[0]);
                })
                .attr("cy", function (d) {
                    return y(d[1]);
                })
                .attr("r", 40);

            searchFirst(g);
        }

        if (response.index === 1) {
            collideTwoDots(g);
        }
        if(response.index === 2){
            expandGraph(g);
        }
        if(response.index === 3){
            makeQuad(g);
        }
    }
    async function searchFirst(g){
        var width = chart.node().getBoundingClientRect().width;
        var height = chart.node().getBoundingClientRect().height;
        var x = d3.scaleLinear()
            .domain([0, 20])//d3.max(data, function(d) { return d[0]; })])
            .range([0, width]);

        var y = d3.scaleLinear()
            .domain([0, 10])//d3.max(data, function(d) { return d[1]; })])
            .range([height, 0]);

        let temp_data = [[6, 5], [12, 5]];
        let temp_path_data = [[6, 5], [6, 5]];
        let line = d3.line()
            .x(function(d) { return x(d[0]); })
            .y(function(d) { return y(d[1]); });

        g.selectAll(".scatter-dots")
            .data(temp_data);
        g.selectAll(".scatter-dots").transition()
            .duration(1000)
            .attr("cx", function (d) {
                return x(d[0]);
            })
            .attr("cy", function (d) {
                return y(d[1]);
            });
        g.selectAll("path")
            .transition()
            .duration(1000)
            .attr("d", line(temp_path_data));
        await sleep(800);
        g.selectAll("path")
            .transition()
            .duration(1200)
            .attr("d", line(temp_data));
        await sleep(1000);
        g.selectAll("path")
            .transition()
            .duration(800)
            .style("stroke", "#32CD32")

    }

    async function collideTwoDots(g){
        small_array[0] = [11, 5];
        small_array[1] = [12, 5];
        for(var i = 0; i < 300; i++){
            big_array[i] = [Math.random()*100 - 50, Math.random()*100 - 50];
        }
        var width = chart.node().getBoundingClientRect().width;
        var height = chart.node().getBoundingClientRect().height;

        var x = d3.scaleLinear()
            .domain([0, 20])//d3.max(data, function(d) { return d[0]; })])
            .range([ 0, width ]);

        var y = d3.scaleLinear()
            .domain([0, 10])//d3.max(data, function(d) { return d[1]; })])
            .range([ height, 0 ]);

        let line = d3.line()
            .x(function(d) { return x(d[0]); })
            .y(function(d) { return y(d[1]); });

        var dots = g.selectAll(".scatter-dots")
            .data(small_array);
        dots.exit().remove();

        g.selectAll(".many-scatter-dots")
            .data(big_array)
            .enter().append("circle")
            .attr("class", "many-scatter-dots")
            .attr("cx", function (d) { return x(d[0]); } )
            .attr("cy", function (d) { return y(d[1]); } )
            .attr("r", 40)
            .style("opacity", 0);

        g.selectAll(".many-scatter-dots")
            .transition()
            .attr("cx", function (d) { return x(d[0]); } )
            .attr("cy", function (d) { return y(d[1]); } )
            .attr("r", 40)
            .style("opacity", 0);

        dots.transition()
            .duration(1000)
            .attr("cx", function (d) { return x(d[0]); } )
            .attr("cy", function (d) { return y(d[1]); } )
            .attr("r", 40);

        g.selectAll("path")
            .style("opacity",0);

        await sleep(800);

        dots.transition()
            .duration(1000)
            .style("fill", "red");

    }
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
    async function expandGraph(g){

  //      small_array[0] = [7, 5];
    //    small_array[1] = [12, 5];
        var width = chart.node().getBoundingClientRect().width;
        var height = chart.node().getBoundingClientRect().height;

        var x = d3.scaleLinear()
            .domain([-50, 50])//d3.max(data, function(d) { return d[0]; })])
            .range([ 0, width ]);

        var y = d3.scaleLinear()
            .domain([-50, 50])//d3.max(data, function(d) { return d[1]; })])
            .range([ height, 0 ]);

        var dots = g.selectAll(".scatter-dots")
            .data(small_array);
        var dots2 = g.selectAll(".many-scatter-dots")
            .data(big_array);

        let mycolor2 = d3.rgb(0, 0, 0);

        dots.transition()
            .duration(1000)
            .attr("cx", function (d) { return x(d[0]); } )
            .attr("cy", function (d) {  return y(d[1]); } )
            .attr("r", 4);

        dots2.transition()
            .duration(1000)
            .attr("cx", function (d) {return x(d[0]); } )
            .attr("cy", function (d) {return y(d[1]); } )
            .style("fill", mycolor2)
            .attr("r", 4)
            .style("opacity", 1);

        await sleep(2000);

        for(var i = 0; i < 300; i++){
            big_array[i] = [Math.random()*100 - 50, Math.random()*100 - 50];
        }

        small_array[0] = [Math.random()*100 - 50, Math.random()*100 - 50];
        small_array[1] = [Math.random()*100 - 50, Math.random()*100 - 50];

        let line = d3.line()
            .x(function(d) { return x(d[0]); })
            .y(function(d) { return y(d[1]); });
        let other_array = [small_array[0], small_array[0]];
        g.selectAll("path")
            .attr("d", line(other_array))
            .style("stroke", "gray")
            .style("stroke-width", "2")
            .style("opacity", "1");

        dots = g.selectAll(".scatter-dots")
            .data(small_array);
        dots2 = g.selectAll(".many-scatter-dots")
            .data(big_array);
        dots2.transition()
            .duration(2000)
            .attr("cx", function (d) {return x(d[0]); } )
            .attr("cy", function (d) {return y(d[1]); } );
        dots.transition()
            .duration(2000)
            .attr("cx", function (d) {return x(d[0]); } )
            .attr("cy", function (d) {return y(d[1]); } );

        await sleep(2000);
        for(let i = 0; i < 10; i++){
            other_array[1] = big_array[i];
            console.log(big_array[i]);
            g.selectAll("path")
                .transition()
                .duration(300)
                .attr("d", line(other_array));
            await sleep(600);
            other_array[1] =other_array[0];
            g.selectAll("path")
                .transition()
                .duration(300)
                .attr("d", line(other_array));
        }
    }

    async function makeQuad(g){

    }

    function handleContainerEnter(response) {
        // response = { direction }
        // sticky the graphic (old school)
        graphic.classed('is-fixed', true);
        graphic.classed('is-bottom', false);
    }
    function handleContainerExit(response) {
        // response = { direction }
        // un-sticky the graphic, and pin to top/bottom of container
        graphic.classed('is-fixed', false);
        graphic.classed('is-bottom', response.direction === 'down');

        let w = window.innerWidth,
            h = window.innerHeight,
            margin = { top: 40, right: 20, bottom: 20, left: 40 },
            radius = 6;

        let svg = d3.select(".quadtree")
            .attr("width", w)
            .attr("height", h);

        var dataset = [
            { x: 100, y: 110 },
            { x: 83, y: 43 },
            { x: 92, y: 28 },
            { x: 49, y: 74 },
            { x: 51, y: 10 },
            { x: 25, y: 98 },
            { x: 77, y: 30 },
            { x: 20, y: 83 },
            { x: 11, y: 63 },
            { x:  4, y: 55 },
            { x:  0, y:  0 },
            { x: 85, y: 100 },
            { x: 60, y: 40 },
            { x: 70, y: 80 },
            { x: 10, y: 20 },
            { x: 40, y: 50 },
            { x: 25, y: 31 }
        ];

        // We're passing in a function in d3.max to tell it what we're maxing (x value)
        var xScale = d3.scaleLinear()
            .domain([0, d3.max(dataset, function (d) { return d.x + 10; })])
            .range([margin.left, w - margin.right]);  // Set margins for x specific

        // We're passing in a function in d3.max to tell it what we're maxing (y value)
        var yScale = d3.scaleLinear()
            .domain([0, d3.max(dataset, function (d) { return d.y + 10; })])
            .range([margin.top, h - margin.bottom]);  // Set margins for y specific

        // Add a X and Y Axis (Note: orient means the direction that ticks go, not position)
        var xAxis = d3.axisTop().scale(xScale);
        var yAxis = d3.axisLeft().scale(yScale);

        svg.selectAll("circle")
            .data(dataset)
            .enter()
            .append("circle")
            .attr("cx", function(d) { return xScale(d.x); },)
            .attr("cy", function(d) { return yScale(d.y); },)// Get attributes from circleAttrs var
            .attr("r", radius)
            .on("mouseover", handleMouseOver)
            .on("mouseout", handleMouseOut);

        // On Click, we want to add data to the array and chart
        svg.on("click", function() {
            let coords = d3.mouse(this);

            // Normally we go from data to pixels, but here we're doing pixels to data
            let newData= {
                x: Math.round( xScale.invert(coords[0])),  // Takes the pixel number to convert to number
                y: Math.round( yScale.invert(coords[1]))
            };

            dataset.push(newData);   // Push data to our array

            svg.selectAll("circle")  // For new circle, go through the update process
                .data(dataset)
                .enter()
                .append("circle")
                .attr("cx", function(d) { return xScale(d.x); })
                .attr("cy", function(d) { return yScale(d.y); })// Get attributes from circleAttrs var
                .attr("r", radius)
                .on("mouseover", handleMouseOver)
                .on("mouseout", handleMouseOut);
        });

        // Create Event Handlers for mouse
        function handleMouseOver(d, i) {  // Add interactivity


            // Use D3 to select element, change color and size
            d3.select(this)
                .style("fill", "steelblue")
                .attr("r", radius * 2);

            // Specify where to put label of text
            svg.append("text")
                .attr("id", "t" + d.x + "-" + d.y + "-" + i)  // Create an id for text so we can select it later for removing on mouseout
                .attr("x",  function() { return xScale(d.x) - 30;})
                .attr("y", function() { return yScale(d.y) - 15; })
                .text(function() { return [d.x, d.y] }); // Value of the text
        }

        function handleMouseOut(d, i) {
            // Use D3 to select element, change color back to normal
            d3.select(this)
                .style("fill", "black")
                .attr("r", radius);

            // Select text by id and then remove
            d3.select("#t" + d.x + "-" + d.y + "-" + i).remove();  // Remove text location
        }
    }
    function init() {
        // 1. force a resize on load to ensure proper dimensions are sent to scrollama
        handleResize();
        // 2. setup the scroller passing options
        // this will also initialize trigger observations
        // 3. bind scrollama event handlers (this can be chained like below)
        scroller.setup({
            container: '#scroll',
            graphic: '.scroll__graphic',
            text: '.scroll__text',
            step: '.scroll__text .step',
            offset: 0.3
        })
            .onStepEnter(handleStepEnter)
            .onContainerEnter(handleContainerEnter)
            .onContainerExit(handleContainerExit);
        // setup resize event
        window.addEventListener('resize', handleResize);
    }
    // kick things off
    init();
</script>
</body>

</html>
