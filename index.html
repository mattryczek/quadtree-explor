<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Quadtrees for Collision Detection Performance</title>
    <meta name="description" content="Quadtrees for Collision Detection">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link href="style.css" rel="stylesheet" type="text/css">
</head>

<body>
<div id='intro'>
    <h1 class="intro__title">Quadtrees for Collision Detection Performance</h1>
    <br>
    <div class="intro__info">
    <p class='intro__text'>
        Most video games rely on some kind of collision detection algorithm in order to implement
        essential gameplay mechanics. Regardless of the chosen algorithm, the problem with existing
        implementation is scale. In many video games, large environments can contain thousands of objects that
        the player can interact with. Currently, the best way to limit computational cost is to decrease the
        number of times the algorithm is run. In order to do this, developers utilize quadtrees,
        a data structure that eliminates checks for impropable collisions. Scroll to explore an illustrated
        breakdown of quadtrees and their use.
        
    </p>
    <p class='intro__text intro__img'>
        <img src="galaga.gif">
    </p>
    </div>
</div>
<section id='scroll'>
    <div class='scroll__graphic'>
        <div class='chart'>
            <svg></svg>
            <p></p>
        </div>
    </div>
    <div class='scroll__text'>
        <div class='step' data-step='1'>
            <p class='step__title'>Small Scale Detection</p>
            <br>
            <p class='step__text'>
                Game engines must be able to update a game's state depending on object interaction
                (or lack thereof), requiring frequent checks for collisions. In this case, we see two 
                objects that don't collide. We use our detection algorithm (shown
                here as a line drawn between objects) to verify this.
            </p>
        </div>
        <div class='step' data-step='2'>
            <p class='step__text'>
                Now, we see two objects that do collide. In this case, detection is trivial, 
                as we're only dealing with two objects. </p> 

        </div>
        <div class='step' data-step='3'>
            <p class='step__title'>Large Scale Detection</p>
            <br>
            <p class="step__text">
                When we have a large number of objects, checking for collisions
                using our current method becomes much more expensive. Users expect
                fluid gameplay, free of constant delays. Although the detection algorithm
                may be completed quickly, performing this computation for all pairs of objects
                has a cost that increases exponentially with the number of objects.
            </p>
            <br><br><br>
            <p class='step__text'>
                Let's look at what happens
                with<br> <input type="number" id = "point_input" name="numObj" value="300" max="1000" min="2"> objects...<br>
                <div id = "counter"></div>
                <button type="button" id="point_input_button">Click Me!</button>
            </p>
        </div>
        <div class='step' data-step='4'>
            <p class='step__title'>Dividing Space to Build a Quadtree</p>
            <br>
            <p class='step__text'>
                How can we cut down on object
                comparisons? Consider the probability that two objects
                collide. This probability is not uniform between all objects - some 
                have a much lower chance of colliding than others. The use of quadtrees
                relies on a simple intuition: objects that are near one another are more likely
                to have collided. To check objects against their neighbors, we first have to 
                figure out which objects are close to each other.
                <br><br>
                In order to create our tree, we recursively divide our 2D space into equally 
                sized quadrants, until each quadrant contains at least one and at most four
                objects.
            </p>
        </div>
        <div class='step' data-step='5'>
            <p class='step__title'>Visualizing the Tree</p>
            <br>
            <p class='step__text'>
                Here's more text for the tree explanation.
            </p>
        </div>
    </div>
</section>
<section id='outro'>
    <svg class="quadtree">

    </svg>
    <svg class="anim">

    </svg>
</section>
<script src='https://d3js.org/d3.v4.min.js'></script>
<script src='https://unpkg.com/intersection-observer'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/scrollama/1.4.1/scrollama.min.js'></script>

<script>
    let container = d3.select('#scroll'),
        graphic = container.select('.scroll__graphic'),
        chart = graphic.select('.chart'),
        text = container.select('.scroll__text'),
        step = text.selectAll('.step'),
        entered = 0;

    let num_points = 30;

    let big_array = d3.range(num_points).map(function() { return [Math.random() * 2048, Math.random() * 2048]; }),
        small_array = new Array(2),
        scroller = scrollama();

    d3.select("#point_input_button")
        .on("click", function() {
            updatePartCount();
        });

    function handleResize() {
        let stepHeight = Math.floor(window.innerHeight * 0.6);

        step.style('height', stepHeight + 'px');

        let bodyWidth = d3.select('body').node().offsetWidth;

        graphic.style('width', bodyWidth + 'px').style('height', window.innerHeight + 'px');

        let chartMargin = 32,
            textWidth = text.node().offsetWidth,
            chartWidth = graphic.node().offsetWidth - textWidth - chartMargin;

        chart.style('width', chartWidth + 'px').style('height', Math.floor(window.innerHeight / 2) + 'px');

        scroller.resize();
    }
    function handleStepEnter(response) {
        let width, height, svg, main, g;

        if(entered === 0){
            width = chart.node().getBoundingClientRect().width;
            height = chart.node().getBoundingClientRect().height;

            let path_data = [[4, 5], [12, 5]];

            svg = chart
                .select('svg')
                .attr('class', 'chart_data')
                .attr('width', width )
                .attr('height',height );

            let line = d3.line()
                .x(d => d[0])
                .y(d => d[1]);

            main = svg.append('g')
                .attr('width', width)
                .attr('height', height)
                .attr('class', 'main');

            g = main.append("svg:g").attr("class", "data_points");

            g.append('path')
                .attr('d', line(path_data))
                .attr("class", "primary_path");

            entered = 1;

        }else{
             width = chart.node().getBoundingClientRect().width;
             height = chart.node().getBoundingClientRect().height;

             svg = chart.select('svg');

             main = svg.select('g');
             g = main.select(".data_points");
        }

        step.classed('is-active', function (d, i) {
            return i === response.index;
        });

        switch (response.index) {
            case 0:
                precedent(width, height, g);
                break;

            case 1:
                collideTwoDots(g);
                break;

            case 2:
                expandGraph(g);
                break;

            case 3:
                makeQuad(g);
                break;
        }
    }

    async function precedent(width, height, g){
        small_array = [[2, 5], [12, 5]];
        let other_array = [[2, 5], [2, 5]];

        var x = d3.scaleLinear()
            .domain([0, 20])
            .range([0, width]);

        var y = d3.scaleLinear()
            .domain([0, 10])
            .range([height, 0]);

        let line = d3.line()
            .x(d => x(d[0]))
            .y(d => y(d[1]));

        g.selectAll("path")
            .attr("d", line(other_array))
            .style("stroke", "black")
            .style("stroke-width", "5");

        g.selectAll(".scatter-dots")
            .data(small_array)
            .enter()
            .append("circle")
            .attr('fill','blue')
            .attr('stroke','black')
            .attr("class", "scatter-dots")
            .attr("cx", d => x(d[0]))
            .attr("cy", d => y(d[1]))
            .attr("r", 40);

        g.selectAll(".scatter-dots")
            .transition()
            .duration(1000)
            .attr("cx", d => x(d[0]))
            .attr("cy", d => y(d[1]))
            .attr("r", 40);

        searchFirst(g);
    }
    async function searchFirst(g){
        let width = chart.node().getBoundingClientRect().width,
            height = chart.node().getBoundingClientRect().height,

            x = d3.scaleLinear()
            .domain([0, 20])
            .range([0, width]),

            y = d3.scaleLinear()
            .domain([0, 10])
            .range([height, 0]);

        let temp_data = [[6, 5], [12, 5]];
        let temp_path_data = [[6, 5], [6, 5]];

        let line = d3.line()
            .x(d => x(d[0]))
            .y(d => y(d[1]));

        g.selectAll(".scatter-dots").data(temp_data);

        g.selectAll(".scatter-dots")
            .transition()
            .duration(1000)
            .attr("cx", d => x(d[0]))
            .attr("cy", d => y(d[1]));

        g.selectAll("path")
            .transition()
            .duration(1000)
            .attr("d", line(temp_path_data));

        await sleep(800);

        g.selectAll("path")
            .transition()
            .duration(1200)
            .attr("d", line(temp_data));

        await sleep(1000);

        g.selectAll("path")
            .transition()
            .duration(800)
            .style("stroke", "#32CD32")
    }

    async function collideTwoDots(g){
        small_array[0] = [11, 5];
        small_array[1] = [12, 5];

        let width = chart.node().getBoundingClientRect().width,
            height = chart.node().getBoundingClientRect().height,

            x = d3.scaleLinear()
            .domain([0, 20])
            .range([ 0, width ]),

            y = d3.scaleLinear()
            .domain([0, 10])
            .range([ height, 0 ]);

        let dots = g.selectAll(".scatter-dots").data(small_array);

        dots.exit().remove();

        g.selectAll(".many-scatter-dots")
            .data(big_array)
            .enter()
            .append("circle")
            .attr("class", "many-scatter-dots")
            .attr("id", function (d, i) {return "point_" + i;})
            .attr("cx", d => x(d[0]))
            .attr("cy", d => y(d[1]))
            .attr("r", 40)
            .style("opacity", 0);

        g.selectAll(".many-scatter-dots")
            .transition()
            .attr("cx", d => x(d[0]))
            .attr("cy", d => y(d[1]))
            .attr("r", 40)
            .style("opacity", 0);

        dots.transition()
            .duration(1000)
            .attr("cx", d => x(d[0]))
            .attr("cy", d => y(d[1]))
            .attr("r", 40);

        g.selectAll("path")
            .style("opacity",0);

        await sleep(800);

        dots.transition()
            .duration(1000)
            .style("fill", "red");

    }
    function sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function expandGraph(g){

        let width = chart.node().getBoundingClientRect().width,
            height = chart.node().getBoundingClientRect().height,

            x = d3.scaleLinear()
                .domain([0, 2048])
                .range([ 0, width]),

            y = d3.scaleLinear()
                .domain([0, 2048])
                .range([ 0, height]);

        let dots = g.selectAll(".scatter-dots")
            .data(small_array),

            dots2 = g.selectAll(".many-scatter-dots")
            .data(big_array);

        dots.transition()
            .duration(1000)
            .attr("cx", d => x(d[0]))
            .attr("cy", d => y(d[1]))
            .attr("r", 4);

        dots2.transition()
            .duration(1000)
            .attr("cx", d => x(d[0]))
            .attr("cy", d => y(d[1]))
            .attr("r", 4)
            .style("fill", d3.rgb(0, 0, 0))
            .style("opacity", 1);

        await sleep(2000);

        drawLines(g, big_array);
    }

    async function drawLines(g, new_array){

        new_array = d3.range(num_points).map(function() { return [Math.random() * 2048, Math.random() * 2048]; });

        small_array[0] = [Math.random()*2048, Math.random()*2048];
        small_array[1] = [Math.random()*2048, Math.random()*2048];

        let width = chart.node().getBoundingClientRect().width,
            height = chart.node().getBoundingClientRect().height,

            x = d3.scaleLinear()
            .domain([0, 2048])
            .range([ 0, width]),

            y = d3.scaleLinear()
            .domain([0, 2048])
            .range([ 0, height]),

            line = d3.line()
                .x(d => x(d[0]))
                .y(d => y(d[1])),

            other_array = [small_array[0], small_array[0]];

        g.selectAll("path")
            .attr("d", line(other_array))
            .style("stroke", "gray")
            .style("stroke-width", "2")
            .style("opacity", "1");

        dots = g.selectAll(".scatter-dots")
            .data(small_array);

        dots2 = g.selectAll(".many-scatter-dots")
            .data(new_array)
            .style("fill", "black");

        dots2.exit().remove();

        dots2.enter().append("circle")
            .attr("class", "many-scatter-dots")
            .attr("id", function (d, i) {return "point_" + i;})
            .attr("cx", d => x(d[0]))
            .attr("cy", d => y(d[1]))
            .attr("r", 4)
            .style("fill", "black")
            .style("opacity", 1);

        dots2.transition()
            .duration(2000)
            .attr("cx", d => x(d[0]))
            .attr("cy", d => y(d[1]));

        dots.transition()
            .duration(2000)
            .attr("cx", d => x(d[0]))
            .attr("cy", d => y(d[1]));

        await sleep(2000);

        for(let i = 0; i < num_points; i++){
            step.select("#counter").html("<br>Particles Checked: " + (i+1));
            other_array[1] = new_array[i];

            g.selectAll("path")
                .transition()
                .duration(30)
                .attr("d", line(other_array));

            g.selectAll("#point_" + i)
                .transition()
                .duration(30)
                .style("fill", "#00FF00");

            await sleep(60);

            other_array[1] =other_array[0];

            g.selectAll("path")
                .transition()
                .duration(30)
                .attr("d", line(other_array));
        }

        big_array = new_array;
    }

    function updatePartCount(){
        let svg = chart.select('svg'),
            main = svg.select(".main"),
            g = main.select(".data_points"),
            val = d3.select("#point_input").node().value;

        num_points = val;

        drawLines(g, new Array(num_points));
    }

    async function makeQuad(g){

        let svg = chart.select("svg"),
            width = +svg.attr("width"),
            height = +svg.attr("height");

        small_array.forEach((function (elem) {
            big_array.push(elem);
        }));

        let quadtree = d3.quadtree()
            .extent([[0, 0], [2048, 2048]])
            .addAll(big_array);

        svg.selectAll(".node")
            .data(nodes(quadtree))
            .enter()
            .append("rect")
            .transition()
            .duration(1000)
            .attr("class", "node")
            .attr("x", function(d) { return (d.x0/2048)*width; })
            .attr("y", function(d) { return (d.y0/2048)*height; })
            .attr("width", function(d) { return ((width/2048)*d.y1) - ((width/2048)*d.y0); })
            .attr("height", function(d) { return ((height/2048)*d.x1) - ((height/2048)*d.x0); });

        function nodes(quadtree) {
            let nodes = [];

            quadtree.visit(function(node, x0, y0, x1, y1) {
                node.x0 = x0,
                    node.y0 = y0,
                    node.x1 = x1,
                    node.y1 = y1;

                nodes.push(node);
            });

            return nodes;
        }
    }

    function build_tree(){
        let w = window.innerWidth,
            h = window.innerHeight,
            margin = { top: 40, right: 20, bottom: 20, left: 40 },
            radius = 6;

        let svg = d3.select(".quadtree")
            .attr("width", w)
            .attr("height", h);

        let dataset = [
            { x: 100, y: 110 },
            { x: 83, y: 43 },
            { x: 92, y: 28 },
            { x: 49, y: 74 },
            { x: 51, y: 10 },
            { x: 25, y: 98 },
            { x: 77, y: 30 },
            { x: 20, y: 83 },
            { x: 11, y: 63 },
            { x:  4, y: 55 },
            { x:  0, y:  0 },
            { x: 85, y: 100 },
            { x: 60, y: 40 },
            { x: 70, y: 80 },
            { x: 10, y: 20 },
            { x: 40, y: 50 },
            { x: 25, y: 31 }
        ];

        // We're passing in a function in d3.max to tell it what we're maxing (x value)
        var xScale = d3.scaleLinear()
            .domain([0, d3.max(dataset, function (d) { return d.x + 10; })])
            .range([margin.left, w - margin.right]);  // Set margins for x specific

        // We're passing in a function in d3.max to tell it what we're maxing (y value)
        var yScale = d3.scaleLinear()
            .domain([0, d3.max(dataset, function (d) { return d.y + 10; })])
            .range([margin.top, h - margin.bottom]);  // Set margins for y specific

        // Add a X and Y Axis (Note: orient means the direction that ticks go, not position)
        var xAxis = d3.axisTop().scale(xScale);
        var yAxis = d3.axisLeft().scale(yScale);

        svg.selectAll("circle")
            .data(dataset)
            .enter()
            .append("circle")
            .attr("cx", function(d) { return xScale(d.x); },)
            .attr("cy", function(d) { return yScale(d.y); },)// Get attributes from circleAttrs var
            .attr("r", radius)
            .on("mouseover", handleMouseOver)
            .on("mouseout", handleMouseOut);

        // On Click, we want to add data to the array and chart
        svg.on("click", function() {
            let coords = d3.mouse(this);

            // Normally we go from data to pixels, but here we're doing pixels to data
            let newData= {
                x: Math.round( xScale.invert(coords[0])),  // Takes the pixel number to convert to number
                y: Math.round( yScale.invert(coords[1]))
            };

            dataset.push(newData);   // Push data to our array

            svg.selectAll("circle")  // For new circle, go through the update process
                .data(dataset)
                .enter()
                .append("circle")
                .attr("cx", d => xScale(d.x))
                .attr("cy", d => yScale(d.y))
                .attr("r", radius)
                .on("mouseover", handleMouseOver)
                .on("mouseout", handleMouseOut);
        });

        // Create Event Handlers for mouse
        function handleMouseOver(d, i) {

            // Use D3 to select element, change color and size
            d3.select(this)
                .style("fill", "steelblue")
                .attr("r", radius * 2);

            // Specify where to put label of text
            svg.append("text")
                .attr("id", "t" + d.x + "-" + d.y + "-" + i)
                .attr("x", () => xScale(d.x) - 30)
                .attr("y", () => yScale(d.y) - 15)
                .text( () => [d.x, d.y] );
        }

        function handleMouseOut(d, i) {
            // Use D3 to select element, change color back to normal
            d3.select(this)
                .style("fill", "black")
                .attr("r", radius);

            // Select text by id and then remove
            d3.select("#t" + d.x + "-" + d.y + "-" + i).remove();  // Remove text location
        }
    }

    function handleContainerEnter(response) {
        graphic.classed('is-fixed', true);
        graphic.classed('is-bottom', false);
    }

    function handleContainerExit(response) {
        graphic.classed('is-fixed', false);
        graphic.classed('is-bottom', response.direction === 'down');

        build_tree();
    }

    function init() {
        handleResize();

        scroller.setup({
            container: '#scroll',
            graphic: '.scroll__graphic',
            text: '.scroll__text',
            step: '.scroll__text .step',
            offset: 0.3
        })
            .onStepEnter(handleStepEnter)
            .onContainerEnter(handleContainerEnter)
            .onContainerExit(handleContainerExit);
        window.addEventListener('resize', handleResize);
    }

    init();

</script>
</body>

</html>
